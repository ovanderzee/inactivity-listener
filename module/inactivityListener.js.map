{"version":3,"file":"inactivityListener.js","sources":["../src/inactivityListener.js","../src/index.js"],"sourcesContent":["const inactivityListener = (function () {\n    // configurable time until callback is executed - Number in milliseconds\n    let timeLimit\n    // configurable function to execute after timeLimit passed - Function\n    let callback\n    // generated id for inactivity span - Number\n    let timeoutId\n    // generated timestamp for start or last activity - Date object\n    let timeRoot\n    // internal events to listen to - String[]\n    let eventTypes\n    // default events to listen to - String[]\n    let standardEventTypes = [\n        'keydown',\n        'keyup', // to be sure\n        'mousemove',\n        'mouseenter', // to be sure\n        'mousedown',\n        'mouseup', // to be sure\n        'scroll',\n        'wheel',\n    ]\n    // internal state; one of 'void', 'busy' or 'lapse' - String\n    let state = 'void'\n\n    /**\n     * Calculate lapsed timeout\n     * @return {Number} milliseconds after start\n     */\n    const elapsed = function () {\n        const past = new Date() - timeRoot\n        return past\n    }\n\n    /**\n     * Execute callback when time is up\n     * @private\n     */\n    const execute = function () {\n        state = 'lapse'\n        try {\n            callback()\n        } catch (error) {\n            console.error('faulty callback')\n        }\n    }\n\n    /**\n     * Put up a new round of waiting\n     * @private\n     */\n    const watch = function () {\n        state = 'busy'\n        timeRoot = new Date()\n        if (timeoutId !== undefined) ignore()\n        timeoutId = setTimeout(execute, timeLimit)\n    }\n\n    /**\n     * Terminate the timeout\n     * @private\n     */\n    const ignore = function () {\n        clearTimeout(timeoutId)\n        timeoutId = undefined\n    }\n\n    /**\n     * Reset critical values\n     * and start waiting again.\n     * Works when the timeout is set\n     */\n    const reset = function () {\n        // only when timeout is set\n        if (state !== 'busy') return\n        ignore()\n        watch()\n    }\n\n    /**\n     * Start waiting with same timelimit and callback\n     * Works when the timeout is completed\n     */\n    const restart = function () {\n        // not when untouched or timing\n        if (state !== 'lapse') return\n        watch()\n    }\n\n    /**\n     * Add or remove EventListeners\n     * @private\n     * @param {String} aim - 'add' | 'remove'\n     */\n    const eventHandling = function (aim) {\n        // event options\n        const eventOptions = { passive: true, capture: true }\n        let count = 0\n\n        eventTypes.forEach(function (type) {\n            const handler = `on${type}`\n            if (handler in window) {\n                window[aim + 'EventListener'](type, reset, eventOptions)\n                count++\n            } else if (handler in document) {\n                document[aim + 'EventListener'](type, reset, eventOptions)\n                count++\n            } else if (aim === 'add') {\n                console.warn(`inactivityListener rejected ${type}-event`)\n            }\n        })\n\n        if (!count && aim === 'add') {\n            console.warn(`inactivityListener resets only on coded calls!`)\n        }\n    }\n\n    /**\n     * Bring in variables, start listeners and timer.\n     * @param {Number} waitTime - time in milliseconds\n     * @param {Function} action - callback\n     * @param {String[]} eventNames - new list of events to watch\n     */\n    const start = function (waitTime, action, eventNames) {\n        timeLimit = waitTime\n        callback = action\n        eventTypes = standardEventTypes\n        if (Array.isArray(eventNames) && eventNames.length) {\n            eventTypes = eventNames.join().toLowerCase().split(',')\n        }\n        if (state === 'void') {\n            eventHandling('add')\n        }\n        watch()\n    }\n\n    /**\n     * Cleanup for single page apps\n     */\n    const stop = function () {\n        state = 'void'\n        ignore()\n        eventHandling('remove')\n    }\n\n    return {\n        start: start,\n        reset: reset,\n        get lapse() {\n            return elapsed()\n        },\n        restart: restart,\n        stop: stop,\n        destroy: stop, // depricate\n    }\n})()\n\nexport { inactivityListener }\n","import { inactivityListener } from './inactivityListener'\n\nconst index = inactivityListener\n\nexport default index\n"],"names":["index","timeLimit","callback","timeoutId","timeRoot","eventTypes","standardEventTypes","state","execute","error","console","watch","Date","undefined","ignore","setTimeout","clearTimeout","reset","eventHandling","aim","eventOptions","passive","capture","count","forEach","type","handler","window","document","warn","stop","start","waitTime","action","eventNames","Array","isArray","length","join","toLowerCase","split","lapse","restart","destroy"],"mappings":"AAAA,MCEMA,EDFqB,WAEvB,IAAIC,EAEAC,EAEAC,EAEAC,EAEAC,EAEAC,EAAqB,CACrB,UACA,QACA,YACA,aACA,YACA,UACA,SACA,SAGAC,EAAQ,OAMZ,MASMC,EAAU,WACZD,EAAQ,QACR,IACIL,IACF,MAAOO,GACLC,QAAQD,MAAM,qBAQhBE,EAAQ,WACVJ,EAAQ,OACRH,EAAW,IAAIQ,UACGC,IAAdV,GAAyBW,IAC7BX,EAAYY,WAAWP,EAASP,IAO9Ba,EAAS,WACXE,aAAab,GACbA,OAAYU,GAQVI,EAAQ,WAEI,SAAVV,IACJO,IACAH,MAkBEO,EAAgB,SAAUC,GAE5B,MAAMC,EAAe,CAAEC,SAAS,EAAMC,SAAS,GAC/C,IAAIC,EAAQ,EAEZlB,EAAWmB,SAAQ,SAAUC,GACzB,MAAMC,EAAU,KAAKD,IACjBC,KAAWC,QACXA,OAAOR,EAAM,iBAAiBM,EAAMR,EAAOG,GAC3CG,KACOG,KAAWE,UAClBA,SAAST,EAAM,iBAAiBM,EAAMR,EAAOG,GAC7CG,KACe,QAARJ,GACPT,QAAQmB,KAAK,+BAA+BJ,cAI/CF,GAAiB,QAARJ,GACVT,QAAQmB,KAAK,mDA0BfC,EAAO,WACTvB,EAAQ,OACRO,IACAI,EAAc,WAGlB,MAAO,CACHa,MAvBU,SAAUC,EAAUC,EAAQC,GACtCjC,EAAY+B,EACZ9B,EAAW+B,EACX5B,EAAaC,EACT6B,MAAMC,QAAQF,IAAeA,EAAWG,SACxChC,EAAa6B,EAAWI,OAAOC,cAAcC,MAAM,MAEzC,SAAVjC,GACAW,EAAc,OAElBP,KAcAM,MAAOA,EACPwB,YACI,OAvHS,IAAI7B,KAASR,GAyH1BsC,QApEY,WAEE,UAAVnC,GACJI,KAkEAmB,KAAMA,EACNa,QAASb,GAzJU"}